#include <iostream>
#include <string>
#include <sys/socket.h>
#include "cache.h"

namespace NetflixCached {

void
Cache::processRequest(const std::pair<int, std::string> request) {
  i = i +1;
  // Pretend we are doing a lot of work
  //std::this_thread::sleep_for(std::chrono::seconds(5));

  // Send a message to the connection
  //std::string response = "Good talking to you\n";
  //send(item.first, response.c_str(), response.size(), 0);

  // Close the connection
  //close(item.first);
  //
  std::string return_status = "ERROR";

  Parser parse_object;
  std::pair<NetflixCached::OpCode,
    std::pair<NetflixCached::Status, NetflixCached::ParsedPayload>>
    result = parse_object.parseRequest(request.second);
  if (result.first == OpCode::ERROR) {
    // Read the type of error generated by the parser
    switch (result.second.first)
    {
      case Status::ERROR:
          break;
      case Status::CLIENT_ERROR:
          return_status.clear();
          return_status = "CLIENT_ERROR";
          break;
      default:
          break;
    }
  } else {
    // stub for caching
    return_status.clear();
    return_status = "STORED";
  }
  // Append "\r\n" to the return_status and send to client
  return_status = return_status + "\r\n";
  send(request.first, return_status.c_str(), return_status.size(), 0);
  std::cout<<"i value = "<<i<<std::endl;
}
} // end NetflixCached
