#pragma once
#include <iostream>       // For std::cout
#include <ctime>          // For time
#include <unordered_map>  // For std::unordered_map
#include <mutex>          // For std::mutex
#include "parser.h"       // For parser API
#include "xxhash.h"       // For xxhash algorithm
#include <queue>          // For std::priority_queue
#define MAX_COMMAND_SIZE 2048 // Maximum text_line command size supported

namespace NetflixCached {
/*
 * Cache infrastructure to maintain Extent-Store and Evicted-Store
 * This interface defines the 'processRequest' API which will parse
 * the request and 'get'/'put' into the cache while returning the
 * corresponding status.
 */
class Cache {
public:
  Cache():done(false){}
  ~Cache() = default;
  /*
   * API invoked by the server threads to process work
   * @param a pair of the socket file descriptor and the string request
   *        received on the network
   */
  virtual void processRequest(const std::pair<int, std::string>);
  /*
   * API used by the inheriting ServerThreadPool interface to queue work
   * to the server threads
   * @param id is the socket file descriptor and req is the network request
   */
  virtual void queueWork(int id, std::string& req) = 0;
  /*
   * API to evict least recently used items from extent-store
   */
  virtual void evictCache();

  virtual void setDone() {
    done = true;
  }

private:
  void getKeyValues(int io_handle, NetflixCached::ParsedPayloadSharedPtr& payload);
  NetflixCached::Status setKeyValue(NetflixCached::ParsedPayloadSharedPtr& payload);

  class HashNode {
  public:
    ~HashNode() = default;
    // The key
    std::string key;

    // Unused flags
    uint32_t flags;

    // The expiry time, which is unused here
    uint32_t exptime;

    // Length of unstructured data
    int length;

    // Unstructured data associated with the key
    std::string unstructured_data;

    // Last accessed time for the object used for eviction
    // This is indicated in seconds since epoch
    time_t last_accessed_time;
  }; // class HashNode

  void addToEvictQueue(size_t& queue_size, Cache::HashNode* node);

  // Actual data-structure to hold all keys in memory. This is based on
  // the standard library and uses std::hash function on the key, thus by
  // reducing the collision probability.
  // Here the Key is the hashed value generated by xxHash and the value is
  // a list of HashNodes to handle collisions if any.
  // The problem of collisions here is solved by separate chaining instead of
  // using cuckoo hash or open-addressing
  std::unordered_map<xxh::hash_t<32>, std::vector<Cache::HashNode *>> extent_store;

  // Mutex to protect the extent_store
  std::mutex extent_store_mutex;

  // Using lambda to compare elements of the 
  //auto cmp = [] (Cache::HashNode* left, Cache::HashNode* right) {
  //  return left->last_accessed_time < right->last_accessed_time;
 // };
  struct Cmp {
    bool operator()(Cache::HashNode* lhs, Cache::HashNode* rhs) {
      return lhs->last_accessed_time < rhs->last_accessed_time;
    }
  };
  std::priority_queue<Cache::HashNode*, std::vector<Cache::HashNode*>, Cmp > evict_pq;

  // Variable to indicate graceful shutdown from the server
  bool done;

}; // class Cache
} // end NetflixCached
