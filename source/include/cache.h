#pragma once
#include <iostream>       // For std::cout
#include <ctime>          // For time
#include <unordered_map>  // For std::unordered_map
#include <mutex>          // For std::mutex
#include "parser.h"       // For parser API
#include "xxhash.h"       // For xxhash algorithm

namespace NetflixCached {
/*
 * Cache infrastructure to maintain Extent-Store and Evicted-Store
 * This interface defines the 'processRequest' API which will parse
 * the request and 'get'/'put' into the cache while returning the
 * corresponding status.
 */
class Cache {
public:
  ~Cache() = default;
  virtual void processRequest(const std::pair<int, std::string>);
  virtual void queueWork(int id, std::string& req) = 0;

private:
  void getKeyValues(int io_handle, NetflixCached::ParsedPayloadSharedPtr& payload);
  NetflixCached::Status setKeyValue(NetflixCached::ParsedPayloadSharedPtr& payload);

  class HashNode {
  public:
    ~HashNode() = default;
    // The key
    std::string key;

    // Unused flags
    uint32_t flags;

    // The expiry time, which is unused here
    uint32_t exptime;

    // Length of unstructured data
    int length;

    // Unstructured data associated with the key
    std::string unstructured_data;

    // Last accessed time for the object used for eviction
    // This is indicated in seconds since epoch
    time_t last_accessed_time;
  }; // class HashNode

  // Actual data-structure to hold all keys in memory. This is based on
  // the standard library and uses std::hash function on the key, thus by
  // reducing the collision probability.
  // Here the Key is the hashed value generated by xxHash and the value is
  // a list of HashNodes to handle collisions if any.
  // The problem of collisions here is solved by separate chaining instead of
  // using cuckoo hash or open-addressing
  std::unordered_map<xxh::hash_t<32>, std::vector<Cache::HashNode *>> extent_store;

  // Mutex to protect the extent_store
  std::mutex extent_store_mutex;
}; // class Cache
} // end NetflixCached
